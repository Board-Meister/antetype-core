var T=(a=>(a.STRUCTURE="antetype.structure",a.MIDDLE="antetype.structure.middle",a.BAR_BOTTOM="antetype.structure.bar.bottom",a.CENTER="antetype.structure.center",a.COLUMN_LEFT="antetype.structure.column.left",a.COLUMN_RIGHT="antetype.structure.column.right",a.BAR_TOP="antetype.structure.bar.top",a.MODULES="antetype.modules",a.ACTIONS="antetype.structure.column.left.actions",a.PROPERTIES="antetype.structure.column.left.properties",a.SHOW_PROPERTIES="antetype.structure.column.left.properties.show",a))(T||{});var E=class{#t;#n=null;#e=null;static inject={minstrel:"boardmeister/minstrel",herald:"boardmeister/herald"};inject(i){this.#t=i}async#o(i,f){if(!this.#e){let u=this.#t.minstrel.getResourceUrl(this,"core.js");this.#n=(await import(u)).default,this.#e=this.#n({canvas:f,modules:i,injected:this.#t})}return this.#e}async register(i){let{modules:f,canvas:u}=i.detail;f.core=await this.#o(f,u)}async init(i){if(!this.#e)throw new Error("Instance not loaded, trigger registration event first");let{base:f,settings:u}=i.detail;for(let m in u)this.#e.setting.set(m,u[m]);let l=this.#e.meta.document;l.base=f;let D=[];return(this.#e.setting.get("fonts")??[]).forEach(m=>{D.push(this.#e.font.load(m))}),await Promise.all(D),l.layout=await this.#e.view.recalculate(l,l.base),await this.#e.view.redraw(l.layout),l}async cloneDefinitions(i){if(!this.#e)throw new Error("Instance not loaded, trigger registration event first");i.detail.element!==null&&(i.detail.element=await this.#e.clone.definitions(i.detail.element))}static subscriptions={[T.MODULES]:"register","antetype.init":"init","antetype.calc":[{method:"cloneDefinitions",priority:-255}]}};function x({modules:a,canvas:i}){let f=i.getContext("2d"),u=50,l=Symbol("original"),D=Symbol("clone"),m=n=>typeof n=="object"&&!Array.isArray(n)&&n!==null,p=function(n){return n[l]??n},w=function(n){return n[D]??n},y=async(n,c,I=0)=>{if(c.has(n))return c.get(n);if(n[l]||n.type==="document")return n;let d={};if(c.set(n,d),d[l]=n,n[D]=d,u<=I+1)throw console.error("We've reach limit depth!",n),new Error("limit reached");return await Promise.all(Object.keys(n).map(async h=>{let s=await b(n[h],n);m(s)?s=await y(s,c,I+1):Array.isArray(s)&&(s=await v(s,c,I+1)),d[h]=s})),d},v=async(n,c,I=0)=>{let d=[];if(u<=I+1)throw console.error("We've reach limit depth!",n),new Error("limit reached");return await Promise.all(n.map(async h=>{let s=await b(h,n);m(s)?s=await y(s,c,I+1):Array.isArray(s)&&(s=await v(s,c,I+1)),d.push(s)})),d},b=async(n,c)=>typeof n=="function"?await n(a,f,c):n;return{isClone:n=>n[l]===!0,cloneDefinitions:async n=>await y(n,new WeakMap),getClone:w,getOriginal:p}}function O(a){let{canvas:i,injected:{herald:f}}=a;if(!i)throw new Error("[Antetype Workspace] Provided canvas is empty");let u={},l=Symbol("layer"),{cloneDefinitions:D,isClone:m,getOriginal:p,getClone:w}=x(a),y={type:"document",base:[],layout:[],start:{x:0,y:0},size:{w:0,h:0}},v=e=>{f.dispatchSync(new CustomEvent("antetype.draw",{detail:{element:e}}))},b=(e=y.layout)=>{for(let t of e)v(t)},k=(e,t,o)=>{e.hierarchy??={parent:t,position:o},t&&(e.hierarchy.parent=t),o&&(e.hierarchy.position=o)},P=async(e,t=null,o=0)=>{let r=p(e);k(r,t?p(t):null,o);let g=new CustomEvent("antetype.calc",{detail:{element:e}});await f.dispatch(g);let C=g.detail.element;return C!==null&&(c(C),k(C,t?w(t):null,o)),C},n=e=>e[l]===!0,c=e=>(e[l]=!0,e),I=async(e=y,t=y.base)=>{c(e);let o=[];for(let r=0;r<t.length;r++){let g=await P(t[r],e,r);g!==null&&o.push(g)}return e.layout=o,o},d=async e=>{if(!e.hierarchy?.parent)return;let t=e.hierarchy.position,o=e.hierarchy.parent,r=await P(e,o,t);if(r===null){L(e),S(e);return}w(o).layout[t]=r},h=async(e,t)=>{e.start=t,await d(e)},s=async(e,t)=>{e.size=t,await d(e)},U=(e,t=null,o=null)=>{t&&m(t)&&(t=p(t));let r=t?t.layout:y.base;t??=y,t.base&&(r=t.base),o??=r.length,B(e,t,o,r)},M=(e,t=null,o=null)=>{t&&!m(t)&&(t=w(t)),t??=y,o??=t.layout.length,B(e,t,o,t.layout)},B=(e,t,o,r)=>{r.splice(o,0,e),e.hierarchy={position:o,parent:t},R(r)},R=e=>{for(let t=0;t<e.length;t++){let o=e[t];o.hierarchy&&(o.hierarchy.position=t)}},L=e=>{if(!e.hierarchy?.parent)return;let t=e.hierarchy.position,o=p(e.hierarchy.parent),r=(o?.type==="document"?o.base:o?.layout)??[];r[t]===p(e)&&(r.splice(t,1),R(r))},S=e=>{if(!e.hierarchy?.parent)return;let t=e.hierarchy.position,r=w(e.hierarchy.parent).layout;r[t]===w(e)&&(r.splice(t,1),R(r))},A=async e=>{let t=new FontFace(e.name,"url("+e.url+")");document.fonts.add(await t.load())};return{meta:{document:y},clone:{definitions:D,getOriginal:p,getClone:w},manage:{markAsLayer:c,move:h,resize:s,remove:L,removeVolatile:S,add:U,addVolatile:M,calcAndUpdateLayer:d},view:{calc:P,recalculate:I,draw:v,redraw:b,redrawDebounce:((e,t=100)=>{let o;return(...r)=>{clearTimeout(o),r[0]!=="clear"&&(o=setTimeout(()=>{e.apply({},r)},t))}})(b)},policies:{isLayer:n,isClone:m},font:{load:A},setting:{set(e,t){u[e]=t},get(e){return u[e]??null},has:e=>!!(u[e]??!1)}}}export{O as default};
